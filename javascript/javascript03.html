<!DOCTYPE html>
<html lang="ko">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>자바스크립트 :: 데이터 실행하기</title>

    <link rel="stylesheet" href="assets/css/style.css">
    <link rel="stylesheet" href="assets/css/default.min.css">
</head>

<body>
    <header id="header">
        <h1>
            <a href="index.html">javascript</a>
        </h1>
        <nav>
            <ul>
                <li><a href="javascript01.html">데이터 저장하기</a></li>
                <li><a href="javascript02.html">데이터 불러오기</a></li>
                <li class="active"><a href="javascript03.html">데이터 실행하기</a></li>
                <li><a href="javascript04.html">데이터 제어하기</a></li>
            </ul>
        </nav>
    </header>
    <!-- //header -->

    <main id="main">
        <div class="main__menu container">
            <ul>
                <li><a href="#">01. 함수 : 선언적 함수</a></li>
                <li><a href="#">02. 함수 : 익명 함수</a></li>
                <li><a href="#">03. 함수 : 매개변수 함수</a></li>
                <li><a href="#">04. 함수 : 리턴값 함수</a></li>
                <li><a href="#">05. 함수 : 매개변수 + 리턴값 함수</a></li>

                <li><a href="#">06. 화살표 함수 : 선언적 함수</a></li>
                <li><a href="#">07. 화살표 함수 : 익명 함수</a></li>
                <li><a href="#">08. 화살표 함수 : 매개변수 함수</a></li>
                <li><a href="#">09. 화살표 함수 : 리턴값 함수</a></li>
                <li><a href="#">10. 화살표 함수 : 매개변수 + 리턴값 함수</a></li>

                <li><a href="#">11. 함수 유형 : 함수와 매개변수를 이용한 형태</a></li>
                <li><a href="#">12. 함수 유형 : 함수와 변수를 이용한 형태</a></li>
                <li><a href="#">13. 함수 유형 : 함수와 배열을 이용한 형태</a></li>
                <li><a href="#">14. 함수 유형 : 함수와 객체를 이용한 형태</a></li>
                <li><a href="#">15. 함수 유형 : 함수와 객체 및 배열을 이용한 형태</a></li>
                <li><a href="#">16. 함수 유형 : 객체안에 함수를 이용한 형태</a></li>
                <li><a href="#">17. 함수 유형 : 객체 생성자 함수</a></li>
                <li><a href="#">18. 함수 유형 : 프로토타입 함수</a></li>
                <li><a href="#">19. 함수 유형 : 객체 리터럴 함수</a></li>

                <li><a href="#">20. 함수 : 즉시실행 함수</a></li>
                <li><a href="#">21. 함수 : 파라미터 함수</a></li>
                <li><a href="#">22. 함수 : 재귀 함수</a></li>
                <li><a href="#">23. 함수 : 콜백 함수</a></li>
                <li><a href="#">24. 함수 : 비동기 방식 : 콜백 함수</a></li>
                <li><a href="#">25. 함수 : 비동기 방식 : 프로미스</a></li>
                <li><a href="#">26. 함수 : 비동기 방식 : asyne/await</a></li>
                <li><a href="#">27. 함수 : 중첩 함수</a></li>
                <li><a href="#">28. 함수 : 클로저 함수</a></li>

                <li><a href="#">29. 클래스 : 기본</a></li>
                <li><a href="#">30. 클래스 : 상속</a></li>
            </ul>
        </div>
        <!-- //main__menu -->

        <div class="main__sample container">
            <div id="sample01" class="sample">
                <h3>01. 함수 : 선언적 함수</h3>
                <p>
                    자바스크립트에서 가장 일반적으로 사용되는 함수(function) 정의 방식 중 하나로<br>
                    이 방식은 function 키워드를 사용하여 함수를 정의하고, 함수의 이름을 지정한 후 중괄호'{}' 내에 함수의 동작을 작성합니다.
                </p>
                <pre><code>{
    function func() {  // 'func' 함수 이름 선언
    console.log("01. 함수가 실행되었습니다.")    // 콘솔에 결과값 출력 
    }
    func();  // 함수 호출
    }</code></pre>
                <div class="result">
                    <details>
                        <summary>결과 확인하기</summary>
                        <div>
                            01. 함수가 실행되었습니다.
                        </div>
                    </details>
                </div>
            </div>
            <!-- //sample01 -->

            <div id="sample02" class="sample">
                <h3>02. 함수 : 익명 함수</h3>
                <p>
                    익명 함수는 주로 다른 함수의 인자로 전달하거나 즉시 실행하는 등의 용도로 사용되고, 함수를 정의할 때 함수 이름을 생략하고 괄호 ()가 나오는 것이 특징입니다.
                </p>
                <pre><code>{
    const func = function () {  // 'const'라는 상수 안에 'func'라는 함수 선언
    console.log("02. 함수가 실행되었습니다.")  // 콘솔에 결과값 출력
    }
    func();  //  함수 호출
}</code></pre>
                <div class="result">
                    <details>
                        <summary>결과 확인하기</summary>
                        <div>
                            02. 함수가 실행되었습니다.
                        </div>
                    </details>
                </div>
            </div>
            <!-- //sample02 -->

            <div id="sample03" class="sample">
                <h3>03. 함수 : 매개변수 함수</h3>
                <p>
                    매개변수 함수란 함수를 호출할 때 매개변수로 값을 전달받아 실행되는 함수를 의미합니다.<br>
                    이 함수는 매개변수(parameter)를 통해 입력값을 받아들이고, 이러한 입력값을 처리하여 결과를 반환하거나 특정 동작을 수행할 수 있습니다.<br>
                    매개변수는 함수를 보다 유연하고 재사용 가능하게 만들며, 코드의 가독성과 유지보수성을 향상시킵니다.
                </p>
                <pre><code>{
    // 선언적 함수
    function func(str) {    // str은 매개변수(parameter)이며, 이 함수가 호출될 때 전달되는 값을 받아들임
    console.log(str);      // console.log()를 사용하여 매개변수 str의 값을 출력
    }
    func("03. 함수가 실행되었습니다.");  // 함수 호출

    // 익명 함수
    const func1 = function(str) {   
    console.log(str);
    }
    func1("03. 함수가 실행되었습니다.");
}</code></pre>
                <div class="result">
                    <details>
                        <summary>결과 확인하기</summary>
                        <div>
                            03. 함수가 실행되었습니다.
                        </div>
                    </details>
                </div>
            </div>
            <!-- //sample03 -->

            <div id="sample04" class="sample">
                <h3>04. 함수 : 리턴값 함수</h3>
                <p>
                    리턴을 정의하는 것은 함수가 값을 반환할 때 사용됩니다. 일반적으로 함수는 계산된 값을 반환하거나 특정 작업을 완료한 후 결과를 반환합니다.<br>
                    이때 return 키워드를 사용하여 값을 반환하는데, 함수 호출시 return 키워드를 만나면 그 즉시 해당 함수의 실행이 종료되고 반환값이 호출한 곳으로 전달됩니다.<br>
                    리턴값 함수는 다른 코드에서 값을 반환할 수 있도록 만들어주며, 이는 프로그램에서 유용한 작업을 수행하는 데 도움이 됩니다. 
                </p>
                <pre><code>{
    //선언적 함수
    function func() {
    return "04. 함수가 실행되었습니다.";
    }
    console.log(func());

    // 익명 함수
    const func1 = function () {
    return "04. 함수가 실행되었습니다.";
    }
    console.log(func1());                  
}</code></pre>
                <div class="result">
                    <details>
                        <summary>결과 확인하기</summary>
                        <div>
                            04. 함수가 실행되었습니다.
                        </div>
                    </details>
                </div>
            </div>
            <!-- //sample04 -->

            <div id="sample05" class="sample">
                <h3>05. 함수 : 매개변수 + 리턴값 함수</h3>
                <p>
                    매개변수와 리턴값을 가지는 함수는 함수가 호출될 때 매개변수를 통해 입력값을 받아들이고, 그 값들을 이용하여 작업을 수행한 후 결과값을 반환하는 함수를 말합니다.
                </p>
                <pre><code>{
    //선언적 함수
    function func(str) {
    return str;
    }
    console.log(func("05. 함수가 실행되었습니다."));

    // 익명 함수
    const func1 = function(str) {
    return str;
    }
    console.log(func1("05. 함수가 실행되었습니다."));
}</code></pre>
                <div class="result">
                    <details>
                        <summary>결과 확인하기</summary>
                        <div>
                            05. 함수가 실행되었습니다.
                        </div>
                    </details>
                </div>
            </div>
            <!-- //sample05 -->

            <div id="sample06" class="sample">
                <h3>화살표 함수 : 선언적 함수</h3>
                <p>
                    화살표 함수는 함수를 정의하는 데 사용되며, 기본적으로 익명 함수로서 변수에 할당되거나, 다른 함수의 매개변수로 전달될 수 있습니다.
                    () => { ... } 형태로 작성되며, ()는 매개변수를 받을 수 있고, =>는 함수의 정의를 나타냅니다. 중괄호{} 내에 함수의 동작이 작성되어 있습니다.
                </p>
                <pre><code>{
    // 일반 함수 표현식
    function add(a, b) {
        return a + b;
    }
        console.log(add(3, 5)); // 출력: 8

    // 매개변수가 없는 화살표 함수 표현식
    const greet = () => {
        return "Hello!";
    };  
        console.log(greet()); // 출력: Hello!

    // 암시적 반환 (함수 바디가 한 줄로 표현되어 있으면 중괄호와 return 키워드를 생략하고 바로 표현식을 작성하여 값을 반환가능)
    const cube = x => x ** 3;          // `cube`라는 이름의 화살표 함수가 정의, 이 함수는 한 개의 매개변수 `x`를 받아서 그 값을 세제곱하여 반환. 이후 `console.log(cube(4));`를 통해 `cube` 함수가 호출되고, 매개변수로 4가 전달. 호출된 `cube` 함수는 매개변수로 전달된 4를 받아서 `x ** 3` 표현식을 계산. 여기서 `x`는 4이므로, 4의 세제곱은 64 

        console.log(cube(4)); // 출력: 64; 
}</code></pre>
                <div class="result">
                    <details>
                        <summary>결과 확인하기</summary>
                        <div>    
                            8<br>
                            Hello!<br>
                            64
                        </div>
                    </details>
                </div>
            </div>
            <!-- //sample06 -->

            <div id="sample07" class="sample">
                <h3>07. 화살표 함수 : 익명 함수</h3>
                <p>
                    화살표 함수는 주로 익명 함수로 사용됩니다. 즉, 함수에 이름을 지정하지 않고 변수에 할당하여 사용하는 것이 일반적입니다.<br>
                    이렇게 하면 함수를 간단하게 선언하고 다른 함수의 인수로
                    전달할 수 있습니다.
                </p>
                <pre><code>{
    // 익명 함수 표현식
    const func = function () {
        console.log("07. 함수가 실행되었습니다.")
    };
    func();

    // 익명 함수 + 화살표 함수 표현식
    const func1 = () => {
        console.log("07. 함수가 실행되었습니다.")
    };
    func1();
}</code></pre>
                <div class="result">
                    <details>
                        <summary>결과 확인하기</summary>
                        <div>                        
                            07. 함수가 실행되었습니다.
                        </div>
                    </details>
                </div>
            </div>
            <!-- //sample07 -->

            <div id="sample08" class="sample">
                <h3>08. 화살표 함수 : 매개변수 함수</h3>
                <p>
                    화살표 함수는 매개변수를 가지고 있는 함수를 간결하게 작성할 수 있는 방법입니다. 매개변수 함수는 함수가 호출될 때 입력값을 받아들이는 함수를 의미합니다.
                </p>
                <pre><code>{
    // 선언적 함수 표현식
    func = (str) => {
        console.log(str);
    }
    func("08. 함수가 실행되었습니다.");

    // 익명 함수 표현식
    const func1 = (str) => {
       console.log(str)
    }
}</code></pre>
                <div class="result">
                    <details>
                        <summary>결과 확인하기</summary>
                        <div>
                            08. 함수가 실행되었습니다.
                        </div>
                    </details>
                </div>
            </div>
            <!-- //sample08 -->

            <div id="sample09" class="sample">
                <h3>09. 화살표 함수 : 리턴값(결과, 종료)</h3>
                <p>
                    화살표 함수(arrow function)에서의 리턴값은 함수가 실행된 후에 반환되는 값입니다. 기존의 함수 선언 방식과 마찬가지로, 화살표 함수에서도 결과를 반환할 수 있습니다.
                </p>
                <pre><code>{
    // 선언적 함수 표현식
    func = () => {
        return "09. 함수가 실행되었습니다.";
    }
        console.log(func());

    // 익명 함수 표현식
    const func1 = () => {
        return "09. 함수가 실행되었습니다.";
    }
        console.log(func1());    
}</code></pre>
                <div class="result">
                    <details>
                        <summary>결과 확인하기</summary>
                        <div>
                            09. 함수가 실행되었습니다.
                        </div>
                    </details>
                </div>
            </div>
            <!-- //sample09 -->

            <div id="sample10" class="sample">
                <h3>10. 화살표 함수 : 매개변수 + 리턴값</h3>
                <p>
                    화살표 함수는 매개변수와 리턴값을 간단하게 처리하는 함수 선언 방식입니다. 매개변수는 함수가 실행될 때 입력으로 전달되는 값으로, 함수 내에서 사용될 수 있습니다.<br>
                    리턴값은 함수가 실행된 후에 반환되는 값으로, 함수가 수행한 작업의 결과입니다. 화살표 함수에서는 화살표 오른쪽에 리턴할 값을 작성합니다.
                </p>
                <pre><code>{
    // 익명 함수(화살표 함수) + 매개변수 + 리턴값 표현식
    const func = (str) => {
        return str;
    }
    console.log("10.함수가 실행되었습니다.")

    // 매개변수 하나이면 괄호 생략 가능
    const func2 = str => {
        return str;
    }
        console.log(runc2("10.함수가 실행되었습니다."));

    // 리턴 생략
    const func3 = str => str;
        console.log(func3("10.함수가 실행되었습니다."));

    // 선언적 함수(가독성 떨어져서 사용 잘 안함)
    func4 = str => str;
        console.log(func3("10.함수가 실행되었습니다."));
}</code></pre>
                <div class="result">
                    <details>
                        <summary>결과 확인하기</summary>
                        <div>
                            10. 함수가 실행되었습니다.
                        </div>
                    </details>
                </div>
            </div>
            <!-- //sample10 -->

            <div id="sample11" class="sample">
                <h3>11. 함수 유형 : 함수와 매개변수를 이용한 형태</h3>
                <p>
                    함수의 입력 값은 매개변수(parameter)를 통해 전달되며, 함수가 작업을 수행한 후에는 그 결과를 반환할 수 있습니다.
                </p>
                <pre><code>{        
    function func(num, str) {
        console.log(num + "." + str);
        console.log(`${num}. ${str}`);
    }
    func(11, "함수가 실행되었습니다.");        
}</code></pre>
                <div class="result">
                    <details>
                        <summary>결과 확인하기</summary>
                        <div>
                            11. 함수가 실행되었습니다.
                        </div>
                    </details>
                </div>
            </div>
            <!-- //sample11 -->

            <div id="sample12" class="sample">
                <h3>12. 함수 유형 : 함수와 변수를 이용한 형태</h3>
                <p>
                    함수 내에서 변수를 정의하고 사용하여 특정 작업을 수행하는 것을 의미합니다. 변수는 함수 내에서만 유효하며, 함수 외부에서는 접근할 수 없습니다.
                </p>
                <pre><code>{
    const num = 12;
    const str = "함수가 실행되었습니다.";

    function func(num, str) {
        console.log(`${num}. ${str}`);
    }
    func(num, str);                
}</code></pre>
                <div class="result">
                    <details>
                        <summary>결과 확인하기</summary>
                        <div>
                            12. 함수가 실행되었습니다.
                        </div>
                    </details>
                </div>
            </div>
            <!-- //sample12 -->

            <div id="sample13" class="sample">
                <h3>13. 함수 유형 : 함수와 배열을 이용한 형태</h3>
                <p>
                    함수를 통해 배열을 조작하고 배열에 대한 작업을 수행하는 방법을 의미합니다. 이 형태는 주로 배열에 대한 반복 작업, 필터링, 매핑 등을 수행할 때 사용됩니다.
                </p>
                <pre><code>{
    const num = [13, 14];
    const str = ["함수가 실행되었습니다.", "함수가 실행되었습니다."];

    function func(num, str) {
        console.log(`${num}. ${str}`);
    }
    func(num[0], str[0]);
    func(num[1], str[1]);
}</code></pre>
                <div class="result">
                    <details>
                        <summary>결과 확인하기</summary>
                        <div>
                            13. 함수가 실행되었습니다.<br>
                            14. 함수가 실행되었습니다.
                        </div>
                    </details>
                </div>
            </div>
            <!-- //sample13 -->

            <div id="sample14" class="sample">
                <h3>14. 함수 유형 : 함수와 객체를 이용한 형태</h3>
                <p>
                    함수와 객체를 이용한 형태는 객체에 대한 작업을 수행하기 위해 함수를 사용하는 방법을 의미합니다. 이 형태는 주로 객체의 속성에 접근하거나 객체의 메서드를 호출하여 특정 작업을
                    수행할 때 사용됩니다.
                </p>
                <pre><code>{
    const info = {
      num: 15,
    str: "함수가 실행되었습니다."
    }
    function func(num, str) {
      console.log(`${num}. ${str}`);
    }
      func(info.num, info.str);
}</code></pre>
                <div class="result">
                    <details>
                        <summary>결과 확인하기</summary>
                        <div>
                            15. 함수가 실행되었습니다.
                        </div>
                    </details>
                </div>
            </div>
            <!-- //sample14 -->

            <div id="sample15" class="sample">
                <h3>15. 함수 유형 : 함수와 객체 및 배열을 이용한 형태</h3>
                <p>
                    함수를 사용하여 객체와 배열을 조작하면 코드를 모듈화하고 재사용할 수 있습니다.
                </p>
                <pre><code>{
    const info = [
    { num: 16, str: "함수가 실행되었습니다." },
    { num: 17, str: "함수가 실행되었습니다." },
    ];
    function func(num, str) {
    console.log(`${num}. ${str}`);
    }
    func(info[0].num, info[0].str);
    func(info[1].num, info[1].str);
}</code></pre>
                <div class="result">
                    <details>
                        <summary>결과 확인하기</summary>
                        <div>
                            16. 함수가 실행되었습니다.<br>
                            17. 함수가 실행되었습니다.
                        </div>
                    </details>
                </div>
            </div>
            <!-- //sample15 -->

            <div id="sample16" class="sample">
                <h3>16. 함수 유형 : 객체안에 함수를 이용한 형태</h3>
                <p>
                    객체안에 함수를 이용하여 객체에 해당 데이터를 조작하는 동작(메서드)을 함께 포함할 수 있습니다. 이것은 데이터와 동작을 논리적으로 그룹화하여 코드의 구조를 보다 명확하게 만들고
                    유지보수성을 향상시킵니다.
                </p>
                <pre><code>{
    const info = {
        num: 18,
        str: "함수가 실행되었습니다.",
        result: () => {
            console.log(`${info.num}. ${info.str}`);
        }
    }
    info.result();
}</code></pre>
                <div class="result">
                    <details>
                        <summary>결과 확인하기</summary>
                        <div>
                            18. 함수가 실행되었습니다.
                        </div>
                    </details>
                </div>
            </div>
            <!-- //sample16 -->

            <div id="sample17" class="sample">
                <h3>17. 함수 유형 : 객체 생성자 함수</h3>
                <p>
                    객체 생성자 함수는 JavaScript에서 객체를 생성하는 데 사용되는 함수입니다. 객체 생성자 함수를 사용하여 동일한 유형의 여러 객체를 생성할 수 있으며, 각 객체는 생성자
                    함수 내에서 정의된 속성과 메서드를 가질 수 있습니다. 일반적으로 객체 생성자 함수는 대문자로 시작하여 PascalCase 표기법을 따르는 관례를 따릅니다.
                </p>
                <pre><code>{
    // 함수 정의
    function Func(num, str) {
        this.num = num;
        this.str = str;
        this.result = () => {
            console.log(`${this.num}. ${this.str}`);
        }
    }
    // 인스턴스 생성
    const info1 = new Func(19, "함수가 실행되었습니다.");
    const info2 = new Func(20, "함수가 실행되었습니다.");

    // 호출
    info1.result();
    info2.result();
}</code></pre>
                <div class="result">
                    <details>
                        <summary>결과 확인하기</summary>
                        <div>
                            19. 함수가 실행되었습니다.<br>
                            20. 함수가 실행되었습니다.
                        </div>
                    </details>
                </div>
            </div>
            <!-- //sample17 -->

            <div id="sample18" class="sample">
                <h3>18. 함수 유형 : 프로토타입 함수</h3>
                <p>
                    모든 JavaScript 객체는 프로토타입(prototype)이라고 불리는 다른 객체를 가지고 있습니다. 이 프로토타입은 해당 객체가 상속(inheritance)할 수 있는 속성과
                    메서드를 정의합니다. 프로토타입 함수는 이러한 프로토타입을 활용하여 모든 객체가 공유하는 메서드를 정의할 때 사용됩니다. 일반적으로 이러한 함수는 객체의 생성자 함수(생성자)의
                    프로토타입 객체에 메서드를 추가하는 형태로 작성됩니다.
                </p>
                <pre><code>{
    // 함수 정의
    function Func(num, str) {
        this.num = num;
        this.str = str;
    }

    // 메서드 추가
    Func.prototype.result = function () {
        console.log(`${this.num}. ${this.str}`);
    }

    // 인스턴스 생성
    const info1 = new Func(21, "함수가 실행되었습니다.");
    const info2 = new Func(22, "함수가 실행되었습니다.");

    // 호출
    info1.result();
    info2.result();
}</code></pre>
                <div class="result">
                    <details>
                        <summary>결과 확인하기</summary>
                        <div>
                            21. 함수가 실행되었습니다.<br>
                            22. 함수가 실행되었습니다.
                        </div>
                    </details>
                </div>
            </div>
            <!-- //sample18 -->

            <div id="sample19" class="sample">
                <h3>19. 함수 유형 : 객체 리터럴 함수 </h3>
                <p>
                    객체 리터럴 함수는 일반적으로 객체를 생성하는 함수를 가리킵니다. 이 함수는 객체 리터럴 문법을 사용하여 새로운 객체를 만들고 반환합니다. 자바스크립트에서 객체는 속성(프로퍼티)과
                    해당 속성에 연결된 동작(메서드)의 집합으로, 객체 리터럴 함수는 새로운 객체를 생성하고 그것의 속성과 메서드를 정의하는 데 사용됩니다.
                </p>
                <pre><code>{
    // 함수 정의
    function Func(num, str) {
        this.num = num;
        this.str = str;
    }

    // 메서드 추가
    Func.prototype = {
        result1: function () {
            console.log(`${this.num}. ${this.str}`);
        },
        result2: function () {
            console.log(`${this.num}. ${this.str}`);
        }
    }

    // 인스턴스 생성
    const info1 = new Func(23, "함수가 실행되었습니다.");
    const info2 = new Func(24, "함수가 실행되었습니다.");

    // 호출
    info1.result1();
    info2.result2();
}</code></pre>
                <div class="result">
                    <details>
                        <summary>결과 확인하기</summary>
                        <div>
                            23. 함수가 실행되었습니다.<br>
                            24. 함수가 실행되었습니다.
                        </div>
                    </details>
                </div>
            </div>
            <!-- //sample19 -->

            <div id="sample20" class="sample">
                <h3>20. 함수: 즉시실행 함수</h3>
                <p>
                    즉시 실행 함수(Immediately Invoked Function Expression, IIFE)는 JavaScript에서 함수를 선언하고 즉시 실행하는 패턴입니다. 이 패턴은
                    전역 스코프를 오염시키지 않고 변수의 충돌을 방지하며, 모듈 패턴이나 비동기 코드에서 주로 사용됩니다.
                </p>
                <pre><code>{
    (function () {
        console.log("15. 실행되었습니다.")
    })();

    (() => {
        console.log("16. 실행되었습니다.");
    })();     
}</code></pre>
                <div class="result">
                    <details>
                        <summary>결과 확인하기</summary>
                        <div>
                            15. 실행되었습니다.<br>
                            16. 실행되었습니다.
                        </div>
                    </details>
                </div>
            </div>
            <!-- //sample20 -->

            <div id="sample21" class="sample">
                <h3>21. 함수: 파라미터 함수</h3>
                <p>
                    파라미터 함수 라는 표현은 일반적으로 함수를 호출할 때 다른 함수를 인수로 전달하는 것을 의미합니다. 이를 통해 함수 간의 상호작용이 가능하며, 코드의 재사용성과 유연성을
                    높일 수 있습니다.
                </p>
                <pre><code>{
    function func(str = "17. 실행되었습니다.") {
        console.log(str)
    }
    func();

    const func1 = (str = "18. 실행되었습니다.") => {
        console.log(str)
    }
    func1();
}</code></pre>
                <div class="result">
                    <details>
                        <summary>결과 확인하기</summary>
                        <div>
                            17. 실행되었습니다.<br>
                            18. 실행되었습니다.
                        </div>
                    </details>
                </div>
            </div>
            <!-- //sample21 -->

            <div id="sample22" class="sample">
                <h3>22. 함수: 재귀 함수</h3>
                <p>
                    재귀 함수(Recursive function)는 함수가 자기 자신을 호출하는 것을 말합니다. 이러한 호출은 일반적으로 함수 내에서 특정 조건을 만족할 때까지 반복됩니다. 재귀
                    함수는 특정 작업을 반복하는 데 사용되며, 반복적인 알고리즘이나 문제 해결 방법에서 특히 유용합니다.
                </p>
                <pre><code>{
    // 01. 반복문을 사용하는 경우            
    function func(num) {
        for (let i = 0; i < num; i++) {
            console.log("19. 실행되었습니다.");
        }
    }
    func(10);

    // 02. 재귀함수 사용하기 (재귀함수 콜백함수 차이점 알기)
    function func1(num) {
        if (num < 1) return;

        console.log("20. 실행되었습니다")
        func1(num - 1); //재귀 호출
    }
    func1(10);
}</code></pre>
                <div class="result">
                    <details>
                        <summary>결과 확인하기</summary>
                        <div>
                            19. 실행되었습니다.*10<br>
                            20. 실행되었습니다.*10
                        </div>
                    </details>
                </div>
            </div>
            <!-- //sample22 -->

            <div id="sample23" class="sample">
                <h3>23. 함수: 콜백 함수</h3>
                <p>
                    콜백 함수(callback function)는 다른 함수에 인수로 전달되어 특정 이벤트가 발생하거나 작업이 완료되었을 때 호출되는 함수입니다. 콜백 함수는 비동기적인 프로그래밍에서
                    주로 사용되며, 이벤트 처리, 데이터베이스 쿼리, 타이머 함수와 같은 작업에서 자주 활용됩니다.
                </p>
                <pre><code>{
    // 01. 이벤트
    function func() {
        console.log("21. 실행되었습니다");
    }
    addEventListener("click", func);     

    // 02. 함수를 다른 함수의 인자로 전달
    function func1() {
        console.log("22. 실행되었습니다")
    }
    function func2(callback) {
        callback();
    }
    func2(func1);

    // 03. 반복문을 사용하는 경우
    function func3(num) {
        console.log(num + ". 실행되었습니다.")
    }
    function func4(callback) {
        for (let i = 23; i < 28; i++) {
            callback(i)
        }
    }
    func4(func3);
}</code></pre>
                <div class="result">
                    <details>
                        <summary>결과 확인하기</summary>
                        <div>
                            22. 실행되었습니다.<br>
                            23. 실행되었습니다.
                            24. 실행되었습니다.
                            25. 실행되었습니다.
                            26. 실행되었습니다.
                            27. 실행되었습니다.
                        </div>
                    </details>
                </div>
            </div>
            <!-- //sample23 -->

            <div id="sample24" class="sample">
                <h3>24. 함수: 비동기 방식: 콜백 함수</h3>
                <p>
                    비동기 방식에서 콜백 함수는 주로 비동기 작업이 완료되었을 때 실행되는 함수로 사용됩니다. 비동기 작업은 일반적으로 네트워크 요청, 파일 읽기/쓰기, 데이터베이스 쿼리 등이
                    포함됩니다. 이러한 작업은 일반적으로 시간이 오래 걸리므로, 이러한 작업이 완료될 때까지 기다리는 대신 콜백 함수를 사용하여 작업이 완료되었을 때 특정 동작을 수행할 수 있습니다.
                </p>
                <pre><code>{
    // 01. 동기적인 함수 호출
    function func1() {
        console.log("29. 실행되었습니다.");
    }
    function func2() {
        console.log("30. 실행되었습니다.");
    }   
    func1();          // 두 개의 함수 func1과 func2를 정의하고, 각각을 호출한 후에 그 결과를 출력
    func2();

    // 02. 비동기적인 함수 호출
    function func3() {
        setTimeout(() => {
            console.log("31. 실행되었습니다.")     // 두 개의 함수 func3와 func4를 정의 후 func3 함수를 호출한 후에 func4 함수를 호출하여 결과를 출력
        }, 1000)                                 // func3 함수를 호출하면, 1초 후에 콘솔에 "31. 실행되었습니다."가 출력되고 이는 setTimeout 함수에 의해 1초의 딜레이 후에 실행되는 함수임            
    }
    function func4() {
        console.log("32. 실행되었습니다.");       // func4 함수를 호출하면, 해당 함수는 즉시 실행되어 "32. 실행되었습니다."를 콘솔에 출력합니다.
    }   
    func3();
    func4();

    // 03. 콜백함수 + 비동기함수 호출
    {
        function func5(callback) {
            setTimeout(() => {
                console.log("33. 실행되었습니다.");  // func5 함수를 정의하고, 이 함수 내에서 1초 후에 "33. 실행되었습니다."를 출력한 후에 콜백 함수를 호출합니다.
                callback();
            }, 1000);
        }
        function func6() {
            console.log("34. 실행되었습니다.");  // func6 함수를 정의하고, 이 함수 내에서 "34. 실행되었습니다."를 출력합니다.
        }
        func5(function () {
            func6();                        // func5 함수를 호출할 때 콜백 함수를 인수로 전달합니다. 이 콜백 함수는 func6 함수를 호출합니다.
        });
    } 
}</code></pre>
                <div class="result">
                    <details>
                        <summary>결과 확인하기</summary>
                        <div>
                            29. 실행되었습니다.<br>
                            30. 실행되었습니다.<br>
                            32. 실행되었습니다.<br>
                            31. 실행되었습니다.<br>
                            33. 실행되었습니다.<br>
                            34. 실행되었습니다.<br>

                        </div>
                    </details>
                </div>
            </div>
            <!-- //sample24 -->

            <div id="sample26" class="sample">
                <h3>26. 함수: 비동기 방식: asyne / await</h3>
                <p>
                    비동기 방식에서 콜백 함수는 주로 비동기 작업이 완료되었을 때 실행되는 함수로 사용됩니다. 비동기 작업은 일반적으로 네트워크 요청, 파일 읽기/쓰기, 데이터베이스 쿼리 등이
                    포함됩니다. 이러한 작업은 일반적으로 시간이 오래 걸리므로, 작업이 완료될 때까지 기다리는 대신 콜백 함수를 사용하여 작업이 완료되었을 때 특정 동작을 수행할 수 있습니다.
                </p>
                <pre><code>{
    // 일반적인 함수 표현식 (동기방식)
    function func() {
        console.log("35. 실행되었습니다.")
    }
    func();

    // 비동기방식 함수 표현식
    async function func2() {
        console.log("36. 실행되었습니다.")      //비동기 함수인 func2는 동작이 완료될 때까지 기다리지 않고 즉시 실행, 즉, 함수 호출 후에 코드의 실행이 계속됩니다.
    }
    func2();

    // 03. 비동기 방식(fetch())  // 리액트에서 제일 많이 사용함
    async function func3() {
        const result = await fetch("https://webstoryboy.github.io/webstoryboy/w_json/gineungsaShort.json")
        const data = await result.json();
        console.log(data);
    }
    func3();
    <p>이 코드는 비동기 함수인 func3를 정의하고 호출합니다. 이 함수는 fetch API를 사용하여 주어진 URL에서 데이터를 가져오고, 그 결과를 콘솔에 출력합니다.

        1. fetch 함수를 사용하여 주어진 URL에서 데이터를 가져옵니다. 이는 비동기 작업으로, 완료될 때까지 기다리지 않고 다음 코드로 진행됩니다.
        2. await result.json()을 사용하여 fetch된 데이터를 JSON 형식으로 변환합니다. 이 또한 비동기 작업으로, 완료될 때까지 기다리지 않고 다음 코드로 진행됩니다.
        3. 변환된 JSON 데이터를 data 변수에 저장합니다.
        4. 마지막으로, console.log(data)를 사용하여 데이터를 콘솔에 출력합니다.
        따라서 실행 결과는 fetch를 통해 해당 URL에서 가져온 데이터를 콘솔에 출력하는 것입니다. 가져온 데이터가 무엇이냐에 따라 출력되는 내용이 달라집니다.<br> 
        해당 URL에서 JSON 형식의 데이터를 가져오는 경우, 그 데이터가 출력됩니다. 만약 데이터가 성공적으로 가져와지지 않았다면, 콘솔에 에러가 출력될 수 있습니다.</p>

    // 04. 비동기 + 에러
    async function func4() {
        try {
            const result = await fetch("https://webstoryboy.github.io/webstoryboy/w_json/gineungsaShort.json")
            const data = await result.json();
            console.log(data);
        } catch (error) {
            console.error(error);
        }
    }
    func4();
    <p>이 코드는 비동기 함수인 func4를 정의하고 호출합니다. 이 함수는 fetch API를 사용하여 주어진 URL에서 데이터를 가져오고, 그 결과를 콘솔에 출력합니다.<br> 
        또한 오류가 발생한 경우에는 에러를 콘솔에 출력합니다.

        1. fetch 함수를 사용하여 주어진 URL에서 데이터를 가져옵니다. 이는 비동기 작업으로, 완료될 때까지 기다리지 않고 다음 코드로 진행됩니다.
        2. await result.json()을 사용하여 fetch된 데이터를 JSON 형식으로 변환합니다. 이 또한 비동기 작업으로, 완료될 때까지 기다리지 않고 다음 코드로 진행됩니다.
        3. 변환된 JSON 데이터를 data 변수에 저장합니다.
        4. 마지막으로, console.log(data)를 사용하여 데이터를 콘솔에 출력합니다.
        만약 데이터를 가져오는 과정에서 오류가 발생하면, try-catch 문을 사용하여 오류를 처리합니다. 
        오류가 발생하면 catch 블록이 실행되어 console.error(error)를 통해 에러를 콘솔에 출력합니다.
        따라서 실행 결과는 fetch를 통해 해당 URL에서 가져온 데이터를 콘솔에 출력하는 것입니다. 가져온 데이터가 무엇이냐에 따라 출력되는 내용이 달라집니다. 가져오는 과정에서 오류가 발생하면, 해당 오류가 콘솔에 출력됩니다.</p>
}</code></pre>
                <div class="result">
                    <details>
                        <summary>결과 확인하기</summary>
                        <div>
                            35. 실행되었습니다.<br>
                            36. 실행되었습니다.<br>

                        </div>
                    </details>
                </div>
            </div>
            <!-- //sample23 -->
        </div>
        <!-- //main__sample -->
    </main>
    <!-- //main -->

    <footer id="footer">
    </footer>
    <!-- //footer -->

    <script src="assets/js/highlight.min.js"></script>
    <script>hljs.highlightAll();</script>
    <script>

        //
        for(let i=0; i<=10; i++){
            console.log(i);
        }

        const num = [100,200,300,400,500];
        
        for(num i=0; i<=num.length; i++){
            console.log(num[i]);
        };

        const arr = [100, 200, 300, 400, 500, 600, 700, 800, 900];      

    for (let i = 0; i < arr.length; i++) {

    console.log(arr[i] + "번");
    }



        // 25. 함수: 비동기 방식: 프로미스
        // {
        //     const func = new Promise((resolve, reject) => {
        //         if (data) {
        //             resolve("35. 실행되었습니다");
        //         } else {
        //             reject("36. 실행되었습니다");
        //         }
        //     })

        //     func
        //         .then(
        //             result => document.write(result)
        //         )
        //         .catch(
        //             error => document.write(error)
        //         )
        // }
       
        // 27. 함수: 중첩 함수
        // 28. 함수: 클로저
        // 29. 클래스: 기본
        // 30. 클래스: 상속


    </script>
</body>

</html>